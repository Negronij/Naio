<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Naio - Llamada</title>
<link rel="icon" href="Naio.png">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js";
import { getDatabase, ref, onValue, set, get, push, remove, off } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-database.js";

// --- Configuración de Firebase (MISMA CONFIGURACIÓN QUE EN index.html) ---
const firebaseConfig = {
  apiKey: "AIzaSyCmzxzDSJFPt7-fDti1PRC-boDE30cJEbM",
  authDomain: "naio1092ngs.firebaseapp.com",
  projectId: "naio1092ngs",
  storageBucket: "naio1092ngs.firebasestorage.app",
  messagingSenderId: "874452485775",
  appId: "1:874452485775:web:25e5ed586fcebe93e952fa",
  measurementId: "G-JBK153N8XL"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

let currentUser = null;
let currentRoomCode = null;
let participantsListener = null;

// --- WebRTC Variables ---
let localStream = null;
const peerConnections = {}; // Guarda las conexiones por UID del otro usuario

const localVideo = document.getElementById('localVideo');
const localDisplayName = document.getElementById('localDisplayName');
const localMicStatus = document.getElementById('localMicStatus');
const localCamStatus = document.getElementById('localCamStatus');
const localVideoContainer = document.getElementById('localVideoContainer');

let isMicMuted = false;
let isCamOff = false;

// --- Autenticación y Carga Inicial ---
onAuthStateChanged(auth, (user) => {
  if (user) {
    currentUser = user;
    const params = new URLSearchParams(window.location.search);
    currentRoomCode = params.get('codigo');

    if (!currentRoomCode) {
      alert("No se especificó un código de sala.");
      window.location.href = "index.html";
      return;
    }

    document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
    joinRoom(currentRoomCode);

    // Iniciar media y listeners después de autenticación y carga de sala
    startMediaStream();
    setupSignalingListener();
    updateLocalMediaStatusInDB(); // Actualizar estado inicial en DB
  } else {
    alert("Debes iniciar sesión para continuar.");
    window.location.href = "index.html";
  }
});

// --- Lógica de Sala y Participantes ---
function joinRoom(codigo) {
  const salaRef = ref(db, 'salas/' + codigo);
  const usuariosSalaRef = ref(db, 'salas/' + codigo + '/usuarios');

  // Añadir al usuario actual a la sala
  set(ref(db, 'salas/' + codigo + '/usuarios/' + currentUser.uid), {
    displayName: currentUser.displayName,
    isMicMuted: false, // Estado inicial
    isCamOff: false    // Estado inicial
  })
    .then(() => {
      console.log(`Usuario ${currentUser.displayName} unido a la sala ${codigo}`);
      updateParticipantListUI();

      participantsListener = onValue(usuariosSalaRef, (snapshot) => {
        updateParticipantListUI();
        handleWebRTCSignaling(snapshot.val());
      });
    })
    .catch((error) => {
      console.error("Error al unirse a la sala o al escuchar participantes:", error);
      alert("No pudimos unirnos a la sala. Verifica el código e inténtalo de nuevo.");
      window.location.href = "index.html";
    });

  // Configurar listener para saber si la sala se ha cerrado
  const salaActivaRef = ref(db, 'salas/' + codigo + '/activo');
  onValue(salaActivaRef, (snapshot) => {
      if (!snapshot.exists() || !snapshot.val()) {
          alert("La sala ha sido cerrada por el creador.");
          leaveRoom();
      }
  }, { onlyOnce: false });
}

function updateParticipantListUI() {
  const salaRef = ref(db, 'salas/' + currentRoomCode + '/usuarios');
  get(salaRef).then((snapshot) => {
    const participantesListDiv = document.getElementById('participantsListCall');
    participantesListDiv.innerHTML = '';
    if (snapshot.exists()) {
      const usuarios = snapshot.val();
      for (const uid in usuarios) {
        const user = usuarios[uid];
        const div = document.createElement('div');
        div.textContent = user.displayName || 'Usuario Desconocido';
        if (user.isMicMuted) {
            const micOffIcon = document.createElement('img');
            micOffIcon.src = 'mic_off.png';
            micOffIcon.alt = 'Muteado';
            micOffIcon.style.height = '16px';
            micOffIcon.style.marginLeft = '5px';
            div.appendChild(micOffIcon);
        }
        if (user.isCamOff) {
            const camOffIcon = document.createElement('img');
            camOffIcon.src = 'cam_off.png';
            camOffIcon.alt = 'Cámara Apagada';
            camOffIcon.style.height = '16px';
            camOffIcon.style.marginLeft = '5px';
            div.appendChild(camOffIcon);
        }
        div.className = 'participant-call-item';
        participantesListDiv.appendChild(div);
      }
    }
  }).catch(error => console.error("Error actualizando lista de participantes:", error));
}

window.leaveRoom = () => {
  if (currentUser && currentRoomCode) {
    // Eliminar al usuario de la sala
    remove(ref(db, 'salas/' + currentRoomCode + '/usuarios/' + currentUser.uid))
      .then(() => {
        console.log(`Usuario ${currentUser.displayName} abandonó la sala ${currentRoomCode}`);
        if (participantsListener) {
          off(ref(db, 'salas/' + currentRoomCode + '/usuarios'), participantsListener);
          participantsListener = null;
        }
        // Cerrar todas las conexiones WebRTC
        for (const uid in peerConnections) {
            peerConnections[uid].close();
            delete peerConnections[uid];
        }
        // Detener stream local
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        window.location.href = "index.html";
      })
      .catch((error) => {
        console.error("Error al abandonar la sala:", error);
        alert("Ocurrió un error al intentar abandonar la sala.");
        window.location.href = "index.html";
      });
  } else {
    window.location.href = "index.html";
  }
}

// --- Lógica de Medios Locales (Cámara/Micrófono) ---

async function startMediaStream() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;
    localVideo.muted = true;
    localDisplayName.textContent = currentUser.displayName; // Mostrar tu nombre
    console.log("Stream de medios iniciado.");

    // Asegurarse de que los estados iniciales se apliquen
    toggleMic(isMicMuted);
    toggleCam(isCamOff);

  } catch (error) {
    console.error("Error al acceder a la cámara o micrófono:", error);
    alert("No se pudo acceder a tu cámara o micrófono. Por favor, verifica los permisos.");
    // Si no se puede acceder, la cámara estará "apagada" por defecto
    isCamOff = true;
    toggleCam(true);
    updateLocalMediaStatusInDB();
  }
}

// Actualizar el estado de mi cámara/micrófono en Firebase
function updateLocalMediaStatusInDB() {
    if (!currentUser || !currentRoomCode) return;
    set(ref(db, `salas/${currentRoomCode}/usuarios/${currentUser.uid}/isMicMuted`), isMicMuted);
    set(ref(db, `salas/${currentRoomCode}/usuarios/${currentUser.uid}/isCamOff`), isCamOff);
}

window.toggleMic = (forceState = null) => {
  isMicMuted = forceState !== null ? forceState : !isMicMuted;
  localStream.getAudioTracks().forEach(track => track.enabled = !isMicMuted);

  const micButton = document.getElementById('micButton');
  const micIcon = micButton.querySelector('img');

  micIcon.src = isMicMuted ? 'mic_off.png' : 'mic.png';
  micButton.title = isMicMuted ? 'Activar Audio' : 'Mutear Audio';

  // Mostrar/ocultar estado del micrófono en mi cuadro de video
  localMicStatus.style.display = isMicMuted ? 'block' : 'none';
  if (isMicMuted) {
      localVideoContainer.classList.add('muted'); // Añadir clase para color rojizo
  } else {
      localVideoContainer.classList.remove('muted');
  }

  updateLocalMediaStatusInDB();
  // Notificar a otros pares sobre el cambio de estado (a través de DB, para que actualicen su UI)
  sendSignalingMessageToAll({ type: 'user_state_update', uid: currentUser.uid, isMicMuted: isMicMuted });
};

window.toggleCam = (forceState = null) => {
  isCamOff = forceState !== null ? forceState : !isCamOff;
  localStream.getVideoTracks().forEach(track => track.enabled = !isCamOff);

  localVideo.style.display = isCamOff ? 'none' : 'block';
  localDisplayName.style.display = isCamOff ? 'block' : 'none'; // Mostrar nombre si cámara apagada

  const camButton = document.getElementById('camButton');
  const camIcon = camButton.querySelector('img');

  camIcon.src = isCamOff ? 'cam_off.png' : 'cam.png';
  camButton.title = isCamOff ? 'Encender Cámara' : 'Apagar Cámara';

  // Mostrar/ocultar estado de la cámara en mi cuadro de video
  localCamStatus.style.display = isCamOff ? 'block' : 'none';

  updateLocalMediaStatusInDB();
  // Notificar a otros pares sobre el cambio de estado
  sendSignalingMessageToAll({ type: 'user_state_update', uid: currentUser.uid, isCamOff: isCamOff });
};

// --- WebRTC Signaling and Connections ---

// Envía un mensaje de señalización a todos los participantes en la sala
function sendSignalingMessageToAll(message) {
    if (!currentRoomCode || !currentUser) return;
    const roomUsersRef = ref(db, `salas/${currentRoomCode}/usuarios`);
    get(roomUsersRef).then(snapshot => {
        if (snapshot.exists()) {
            const users = snapshot.val();
            for (const uid in users) {
                if (uid !== currentUser.uid) { // No enviar mensaje a uno mismo
                    sendSignalingMessage(uid, message);
                }
            }
        }
    }).catch(error => console.error("Error obteniendo usuarios para señalización a todos:", error));
}


function handleWebRTCSignaling(currentParticipants) {
  if (!currentParticipants) return;

  const participantUIDs = Object.keys(currentParticipants);

  // 1. Iniciar o mantener conexiones con participantes activos
  participantUIDs.forEach(uid => {
    if (uid === currentUser.uid) return;

    if (!peerConnections[uid]) {
      console.log(`Iniciando conexión con ${currentParticipants[uid].displayName} (${uid})`);
      peerConnections[uid] = createPeerConnection(uid, currentParticipants[uid].displayName);
      // Cuando un nuevo usuario se une, enviar una oferta.
      // Esto es crucial para iniciar la conexión cuando alguien entra.
      peerConnections[uid].createOffer()
        .then(offer => peerConnections[uid].setLocalDescription(offer))
        .then(() => sendSignalingMessage(uid, { type: 'offer', sdp: peerConnections[uid].localDescription }))
        .catch(error => console.error("Error creando oferta inicial:", error));
    }
  });

  // 2. Eliminar conexiones con usuarios que ya no están en la sala
  for (const uid in peerConnections) {
    if (!participantUIDs.includes(uid)) {
      console.log(`Cerrando conexión con un usuario (${uid}) que abandonó.`);
      peerConnections[uid].close();
      delete peerConnections[uid];
      const remoteVideoDiv = document.getElementById(`remoteVideoContainer-${uid}`);
      if (remoteVideoDiv) {
        remoteVideoDiv.remove();
      }
    }
  }

  // 3. Actualizar el estado de los medios remotos
  for (const uid in currentParticipants) {
      if (uid === currentUser.uid) continue;
      const user = currentParticipants[uid];
      const remoteVideoDiv = document.getElementById(`remoteVideoContainer-${uid}`);
      if (remoteVideoDiv) {
          const remoteVideo = remoteVideoDiv.querySelector('video');
          const remoteDisplayName = remoteVideoDiv.querySelector('.remote-display-name');
          const remoteMicStatus = remoteVideoDiv.querySelector('.remote-mic-status');
          const remoteCamStatus = remoteVideoDiv.querySelector('.remote-cam-status');

          if (user.isCamOff) {
              if (remoteVideo) remoteVideo.style.display = 'none';
              if (remoteDisplayName) remoteDisplayName.style.display = 'block';
              remoteVideoDiv.classList.add('camera-off');
          } else {
              if (remoteVideo) remoteVideo.style.display = 'block';
              if (remoteDisplayName) remoteDisplayName.style.display = 'none';
              remoteVideoDiv.classList.remove('camera-off');
          }

          if (user.isMicMuted) {
              remoteMicStatus.style.display = 'block';
              remoteVideoDiv.classList.add('muted'); // Color rojizo para el usuario muteado
          } else {
              remoteMicStatus.style.display = 'none';
              remoteVideoDiv.classList.remove('muted');
          }

          if (user.isCamOff) {
              remoteCamStatus.style.display = 'block';
          } else {
              remoteCamStatus.style.display = 'none';
          }
      }
  }
}

function createPeerConnection(remoteUserUID, remoteUserName) {
  const pc = new RTCPeerConnection({
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
    ]
  });

  // Crear contenedor para el video remoto
  const remoteVideoDiv = document.createElement('div');
  remoteVideoDiv.id = `remoteVideoContainer-${remoteUserUID}`;
  remoteVideoDiv.className = 'remote-video-container';

  const videoElement = document.createElement('video');
  videoElement.id = `remoteVideo-${remoteUserUID}`;
  videoElement.autoplay = true;
  videoElement.playsinline = true;
  videoElement.className = 'remote-video';

  const displayNameElement = document.createElement('div');
  displayNameElement.className = 'remote-display-name';
  displayNameElement.textContent = remoteUserName;
  displayNameElement.style.display = 'none'; // Oculto por defecto

  const micStatusIcon = document.createElement('img');
  micStatusIcon.src = 'mic_off.png';
  micStatusIcon.alt = 'Mic Muteado';
  micStatusIcon.className = 'status-icon remote-mic-status';
  micStatusIcon.style.display = 'none';

  const camStatusIcon = document.createElement('img');
  camStatusIcon.src = 'cam_off.png';
  camStatusIcon.alt = 'Cámara Apagada';
  camStatusIcon.className = 'status-icon remote-cam-status';
  camStatusIcon.style.display = 'none';

  remoteVideoDiv.appendChild(videoElement);
  remoteVideoDiv.appendChild(displayNameElement);
  remoteVideoDiv.appendChild(micStatusIcon);
  remoteVideoDiv.appendChild(camStatusIcon);
  document.getElementById('remoteVideoContainer').appendChild(remoteVideoDiv);

  pc.ontrack = (event) => {
    console.log(`Track remoto recibido de ${remoteUserName}`);
    videoElement.srcObject = event.streams[0];
  };

  pc.onicecandidate = (event) => {
    if (event.candidate) {
      sendSignalingMessage(remoteUserUID, {
        type: 'candidate',
        candidate: event.candidate
      });
    }
  };

  // Añadir nuestro stream local a la conexión
  if (localStream) {
    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
    });
  } else {
    console.warn("localStream no está disponible al crear PeerConnection para", remoteUserName);
  }

  return pc;
}

function sendSignalingMessage(targetUserUID, message) {
  if (!currentRoomCode || !currentUser) return;
  const messagesRef = ref(db, `salas/${currentRoomCode}/signaling/${targetUserUID}/${currentUser.uid}`);
  set(messagesRef, message)
    .catch(error => console.error("Error enviando mensaje de señalización:", error));
}

function setupSignalingListener() {
  if (!currentRoomCode || !currentUser) return;
  const mySignalingRef = ref(db, `salas/${currentRoomCode}/signaling/${currentUser.uid}`);

  onValue(mySignalingRef, async (snapshot) => {
    if (snapshot.exists()) {
      const messages = snapshot.val();
      for (const senderUID in messages) {
        const signalingMessage = messages[senderUID];

        let pc = peerConnections[senderUID];
        if (!pc) {
            // Si el mensaje es una oferta, creamos la PeerConnection
            if (signalingMessage.type === 'offer') {
                const senderData = await get(ref(db, `salas/${currentRoomCode}/usuarios/${senderUID}`));
                if (senderData.exists()) {
                    pc = createPeerConnection(senderUID, senderData.val().displayName || 'Usuario Desconocido');
                    peerConnections[senderUID] = pc;
                } else {
                    console.warn("Datos del remitente no encontrados para oferta:", senderUID);
                    continue;
                }
            } else {
                console.warn(`Mensaje de ${signalingMessage.type} recibido antes de que la PeerConnection fuera creada para ${senderUID}.`);
                continue;
            }
        }

        try {
          if (signalingMessage.type === 'offer') {
            await pc.setRemoteDescription(new RTCSessionDescription(signalingMessage.sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            sendSignalingMessage(senderUID, { type: 'answer', sdp: pc.localDescription });
          } else if (signalingMessage.type === 'answer') {
            await pc.setRemoteDescription(new RTCSessionDescription(signalingMessage.sdp));
          } else if (signalingMessage.type === 'candidate') {
            await pc.addIceCandidate(new RTCIceCandidate(signalingMessage.candidate));
          } else if (signalingMessage.type === 'user_state_update') {
              // Esto actualiza el estado local de los iconos, la UI se actualiza con handleWebRTCSignaling
              console.log(`Estado de usuario ${senderUID} actualizado:`, signalingMessage);
          }
        } catch (error) {
          console.error(`Error procesando mensaje de señalización de ${senderUID} (${signalingMessage.type}):`, error);
        }

        // Eliminar el mensaje una vez procesado
        remove(ref(db, `salas/${currentRoomCode}/signaling/${currentUser.uid}/${senderUID}`));
      }
    }
  });
}

// Limpiar listeners al salir de la página
window.addEventListener('beforeunload', () => {
    if (participantsListener) {
        off(ref(db, 'salas/' + currentRoomCode + '/usuarios'), participantsListener);
    }
    // Cerrar todas las conexiones WebRTC activas
    for (const uid in peerConnections) {
        peerConnections[uid].close();
    }
    // Detener el stream local
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }
    // Eliminar el estado de medios del usuario actual al salir de la página
    if (currentUser && currentRoomCode) {
        remove(ref(db, 'salas/' + currentRoomCode + '/usuarios/' + currentUser.uid));
    }
});


// --- Funciones auxiliares para el modal de participantes en call.html ---
function verParticipantesModal() {
    const participantesListDiv = document.getElementById('participantsListCall');
    participantesListDiv.innerHTML = ''; // Limpiar lista anterior

    const salaRef = ref(db, 'salas/' + currentRoomCode + '/usuarios');
    get(salaRef).then((snapshot) => {
        if (snapshot.exists()) {
            const usuarios = snapshot.val();
            for (const uid in usuarios) {
                const user = usuarios[uid];
                const div = document.createElement('div');
                div.textContent = user.displayName || 'Usuario Desconocido';
                if (user.isMicMuted) {
                    const micOffIcon = document.createElement('img');
                    micOffIcon.src = 'mic_off.png';
                    micOffIcon.alt = 'Muteado';
                    micOffIcon.style.height = '16px';
                    micOffIcon.style.marginLeft = '5px';
                    div.appendChild(micOffIcon);
                }
                if (user.isCamOff) {
                    const camOffIcon = document.createElement('img');
                    camOffIcon.src = 'cam_off.png';
                    camOffIcon.alt = 'Cámara Apagada';
                    camOffIcon.style.height = '16px';
                    camOffIcon.style.marginLeft = '5px';
                    div.appendChild(camOffIcon);
                }
                div.className = 'participant-call-item';
                participantesListDiv.appendChild(div);
            }
            document.getElementById('participantsModalCall').style.display = 'flex';
        } else {
            alert("No se encontraron participantes para esta sala.");
        }
    }).catch(error => console.error("Error al obtener participantes:", error));
}

function cerrarParticipantesModal() {
    document.getElementById('participantsModalCall').style.display = 'none';
}
</script>

<style>
:root {
  --primary-color: #FF6F00;
  --background-dark: #0f0f1a;
  --text-light: #e0e0e0;
  --card-background: rgba(255, 255, 255, 0.08);
  --participant-bg: rgba(255, 255, 255, 0.1);
  --muted-red: #e53935; /* Color rojizo para indicar muteado */
}

body {
  margin: 0;
  font-family: 'Montserrat', sans-serif;
  background-color: var(--background-dark);
  color: var(--text-light);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  min-height: 100vh;
  overflow-y: auto;
  padding: 20px;
  box-sizing: border-box;
}

.header {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 10px 20px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.header .room-info {
  font-size: 1.1em;
  font-weight: 700;
  color: var(--primary-color);
}

.header .room-code {
  font-size: 1.2em;
  color: white;
  background-color: var(--primary-color);
  padding: 8px 15px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.call-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  max-width: 1200px;
}

.video-area {
  width: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); /* Min ancho de 280px */
  gap: 15px;
  justify-content: center;
  align-items: start;
}

/* Contenedor de video local */
#localVideoContainer, .remote-video-container {
  position: relative;
  background-color: var(--participant-bg);
  border-radius: 15px; /* Bordes más redondeados */
  overflow: hidden;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  aspect-ratio: 16 / 9;
  min-width: 280px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.4);
  transition: background-color 0.3s ease, border 0.3s ease;
  border: 2px solid transparent; /* Borde por defecto */
}

/* Efecto rojizo cuando el usuario está muteado */
#localVideoContainer.muted, .remote-video-container.muted {
    background-color: rgba(var(--muted-red), 0.3);
    border: 2px solid var(--muted-red);
}

/* Efecto para cámara apagada (opcional, si quieres un fondo diferente) */
#localVideoContainer.camera-off, .remote-video-container.camera-off {
    background-color: rgba(100, 100, 100, 0.2);
}


#localVideo, .remote-video {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transform: scaleX(-1); /* Voltear horizontalmente solo para video local y remoto */
  display: block; /* Visible por defecto */
}
.remote-video-container .remote-video {
    transform: scaleX(-1); /* También voltear videos remotos para consistencia */
}


#localDisplayName, .remote-display-name {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.8em;
  font-weight: 700;
  color: white;
  text-shadow: 0 2px 5px rgba(0,0,0,0.6);
  z-index: 5;
  padding: 10px 20px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 10px;
  display: none; /* Oculto por defecto */
  text-align: center;
  pointer-events: none; /* Para que no interfiera con el video subyacente */
}

/* Iconos de estado (mute, cámara apagada) */
.status-icon {
    position: absolute;
    top: 10px;
    right: 10px;
    height: 30px; /* Tamaño del icono */
    width: 30px;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 50%;
    padding: 5px;
    z-index: 10;
    display: none; /* Oculto por defecto */
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

/* Asegurar que el icono de cámara apagada no esté volteado */
.status-icon.remote-cam-status, .status-icon.local-cam-status {
    transform: none;
}


.controls {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap; /* Permitir que los botones se envuelvan en pantallas pequeñas */
  gap: 15px;
  margin-top: 20px;
}

.controls button {
  cursor: pointer;
  font-size: 16px;
  font-weight: 700;
  border: none;
  border-radius: 10px;
  padding: 12px 25px;
  transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-light); /* Color de texto por defecto */
  background-color: var(--card-background); /* Fondo por defecto */
}

.controls button:hover {
  transform: translateY(-3px) scale(1.03);
  box-shadow: 0 4px 15px rgba(255, 111, 0, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3);
}

.controls button img {
    height: 24px; /* Tamaño de los iconos PNG */
    width: 24px;
}

.controls .leave-button {
  background-color: #e53935;
  color: white;
}
.controls .leave-button:hover {
  background-color: #f44336;
  box-shadow: 0 4px 15px rgba(229, 57, 53, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3);
}

/* Modal de participantes */
#participantsModalCall {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(15, 15, 26, 0.95);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(5px);
}

#participantsModalCall .modal-content {
  background: rgba(30, 30, 50, 0.8);
  padding: 30px;
  border-radius: 15px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 90%;
  max-width: 450px;
  text-align: center;
}

#participantsModalCall h3 {
  font-size: 26px;
  margin-bottom: 20px;
  color: var(--primary-color);
  font-weight: 700;
}

#participantsListCall {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 40vh;
  overflow-y: auto;
  margin-bottom: 25px;
  width: 100%;
  padding-right: 10px;
}

.participant-call-item {
  background: var(--card-background);
  padding: 10px 18px;
  border-radius: 8px;
  font-size: 17px;
  color: var(--text-light);
  text-align: left;
  transition: background-color 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: space-between; /* Para iconos de estado */
}
.participant-call-item img {
    margin-left: 10px;
}

#participantsModalCall .modal-content button {
  background: var(--primary-color);
  color: white;
  width: auto;
  padding: 12px 30px;
}
#participantsModalCall .modal-content button:hover {
  background: #FF8F33;
}

/* Ajustes para pantallas pequeñas */
@media (max-width: 768px) {
  .header {
    flex-direction: column;
    gap: 10px;
  }
  .call-container {
    gap: 15px;
  }
  .video-area {
    grid-template-columns: 1fr;
  }
  .controls {
    flex-wrap: wrap;
  }
  .controls button {
    width: 100%; /* Botones de control ocupan todo el ancho */
    justify-content: center;
  }
}
</style>
</head>
<body>

<header class="header">
  <div class="room-info">Sala: <span id="roomCodeDisplay"></span></div>
  <button onclick="verParticipantesModal()" class="mute-button">Ver Participantes</button>
  <button onclick="leaveRoom()" class="leave-button">Abandonar Sala</button>
</header>

<div class="call-container">
  <div class="video-area">
    <div id="localVideoContainer">
      <video id="localVideo" autoplay playsinline></video>
      <div id="localDisplayName" class="display-name"></div>
      <img id="localMicStatus" src="mic_off.png" alt="Muteado" class="status-icon local-mic-status">
      <img id="localCamStatus" src="cam_off.png" alt="Cámara Apagada" class="status-icon local-cam-status">
    </div>

    <div id="remoteVideoContainer">
      </div>
  </div>

  <div class="controls">
    <button id="micButton" onclick="toggleMic()" title="Mutear Audio">
      <img src="mic.png" alt="Micrófono">
      <span>Audio</span>
    </button>
    <button id="camButton" onclick="toggleCam()" title="Apagar Cámara">
      <img src="cam.png" alt="Cámara">
      <span>Video</span>
    </button>
  </div>
</div>

<div id="participantsModalCall">
  <div class="modal-content">
    <h3>Participantes en la Sala</h3>
    <div id="participantsListCall"></div>
    <button onclick="cerrarParticipantesModal()">Cerrar</button>
  </div>
</div>

</body>
</html>
