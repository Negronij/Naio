<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Naio - Llamada</title>
<link rel="icon" href="Naio.png">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js";
import { getDatabase, ref, onValue, set, get, push, remove, off } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-database.js";

// --- Configuración de Firebase (MISMA CONFIGURACIÓN QUE EN index.html) ---
const firebaseConfig = {
  apiKey: "AIzaSyCmzxzDSJFPt7-fDti1PRC-boDE30cJEbM",
  authDomain: "naio1092ngs.firebaseapp.com",
  projectId: "naio1092ngs",
  storageBucket: "naio1092ngs.firebasestorage.app",
  messagingSenderId: "874452485775",
  appId: "1:874452485775:web:25e5ed586fcebe93e952fa",
  measurementId: "G-JBK153N8XL"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

let currentUser = null;
let currentRoomCode = null;
let participantsListener = null;

// --- WebRTC Variables ---
let localStream = null;
const peerConnections = {}; // Guarda las conexiones por UID del otro usuario

const localVideo = document.getElementById('localVideo');
const localDisplayName = document.getElementById('localDisplayName');
const localMicStatus = document.getElementById('localMicStatus');
const localCamStatus = document.getElementById('localCamStatus');
const localVideoContainer = document.getElementById('localVideoContainer');

let isMicMuted = false;
let isCamOff = false;

// --- Autenticación y Carga Inicial ---
onAuthStateChanged(auth, (user) => {
  if (user) {
    currentUser = user;
    const params = new URLSearchParams(window.location.search);
    currentRoomCode = params.get('codigo');

    if (!currentRoomCode) {
      alert("No se especificó un código de sala.");
      window.location.href = "index.html";
      return;
    }

    document.getElementById('roomCodeDisplay').textContent = currentRoomCode;

    // Solo unirse a la sala si hay un usuario autenticado y un código de sala
    joinRoom(currentRoomCode);

  } else {
    alert("Debes iniciar sesión para continuar.");
    window.location.href = "index.html";
  }
});

// --- Lógica de Sala y Participantes ---
async function joinRoom(codigo) {
    try {
        const salaRef = ref(db, 'salas/' + codigo);
        const usuariosSalaRef = ref(db, 'salas/' + codigo + '/usuarios');

        // Empezar a capturar los medios ANTES de unirse a la sala.
        await startMediaStream();

        // Añadir al usuario actual a la sala
        await set(ref(db, 'salas/' + codigo + '/usuarios/' + currentUser.uid), {
            displayName: currentUser.displayName,
            isMicMuted: false, // Estado inicial: no muteado
            isCamOff: false    // Estado inicial: cámara encendida
        });

        console.log(`Usuario ${currentUser.displayName} unido a la sala ${codigo}`);
        
        // Configurar listener para saber si la sala se ha cerrado
        const salaActivaRef = ref(db, 'salas/' + codigo + '/activo');
        onValue(salaActivaRef, (snapshot) => {
            if (!snapshot.exists() || !snapshot.val()) {
                alert("La sala ha sido cerrada por el creador.");
                leaveRoom();
            }
        }, { onlyOnce: false });

        // Escuchar cambios en los participantes para manejar las conexiones P2P
        participantsListener = onValue(usuariosSalaRef, (snapshot) => {
            updateParticipantListUI(); // Actualiza la lista de participantes en el modal
            handleWebRTCSignaling(snapshot.val()); // Maneja la lógica WebRTC
        });

        // Configurar el listener de señalización DESPUÉS de unirse a la sala
        setupSignalingListener();

    } catch (error) {
        console.error("Error al unirse a la sala o al iniciar el stream:", error);
        alert("No pudimos unirnos a la sala o acceder a tu cámara/micrófono. Verifica el código e inténtalo de nuevo.");
        window.location.href = "index.html";
    }
}

function updateParticipantListUI() {
    const salaRef = ref(db, 'salas/' + currentRoomCode + '/usuarios');
    get(salaRef).then((snapshot) => {
        const participantesListDiv = document.getElementById('participantsListCall');
        participantesListDiv.innerHTML = '';
        if (snapshot.exists()) {
            const usuarios = snapshot.val();
            for (const uid in usuarios) {
                const user = usuarios[uid];
                const div = document.createElement('div');
                div.textContent = user.displayName || 'Usuario Desconocido';
                
                // Mostrar iconos de estado si el usuario está muteado o la cámara apagada
                if (user.isMicMuted) {
                    const micOffIcon = document.createElement('img');
                    micOffIcon.src = 'mic_off.png';
                    micOffIcon.alt = 'Muteado';
                    micOffIcon.style.height = '16px';
                    micOffIcon.style.marginLeft = '5px';
                    div.appendChild(micOffIcon);
                }
                if (user.isCamOff) {
                    const camOffIcon = document.createElement('img');
                    camOffIcon.src = 'cam_off.png';
                    camOffIcon.alt = 'Cámara Apagada';
                    camOffIcon.style.height = '16px';
                    camOffIcon.style.marginLeft = '5px';
                    div.appendChild(camOffIcon);
                }
                div.className = 'participant-call-item';
                participantesListDiv.appendChild(div);
            }
        }
    }).catch(error => console.error("Error actualizando lista de participantes:", error));
}

window.leaveRoom = () => {
    if (currentUser && currentRoomCode) {
        // Eliminar al usuario de la lista de participantes en Firebase
        remove(ref(db, 'salas/' + currentRoomCode + '/usuarios/' + currentUser.uid))
            .then(() => {
                console.log(`Usuario ${currentUser.displayName} abandonó la sala ${currentRoomCode}`);
                // Detener listeners y cerrar conexiones
                if (participantsListener) {
                    off(ref(db, 'salas/' + currentRoomCode + '/usuarios'), participantsListener);
                    participantsListener = null;
                }
                for (const uid in peerConnections) {
                    peerConnections[uid].close();
                    delete peerConnections[uid];
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                window.location.href = "index.html"; // Redirigir al lobby
            })
            .catch((error) => {
                console.error("Error al abandonar la sala:", error);
                alert("Ocurrió un error al intentar abandonar la sala.");
                window.location.href = "index.html";
            });
    } else {
        window.location.href = "index.html"; // Si algo falla, ir al lobby
    }
}

// --- Lógica de Medios Locales (Cámara/Micrófono) ---
async function startMediaStream() {
    try {
        // Solicitar acceso a la cámara y micrófono
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream; // Mostrar tu propio video en el cuadro local
        localVideo.muted = true; // Para evitar eco al escucharte a ti mismo
        localDisplayName.textContent = currentUser.displayName; // Mostrar tu nombre debajo de tu video
        console.log("Stream de medios locales iniciado.");

        // Asegurarse de que los estados iniciales de micrófono/cámara se apliquen
        toggleMic(isMicMuted);
        toggleCam(isCamOff);

    } catch (error) {
        console.error("Error al acceder a la cámara o micrófono:", error);
        alert("No se pudo acceder a tu cámara o micrófono. Por favor, verifica los permisos del navegador.");
        isCamOff = true; // Si hay error, forzar que la cámara esté "apagada"
        toggleCam(true); // Actualizar UI y estado
    }
}

// Actualiza el estado del micrófono y la cámara en Firebase para que otros lo vean
function updateLocalMediaStatusInDB() {
    if (!currentUser || !currentRoomCode) return;
    set(ref(db, `salas/${currentRoomCode}/usuarios/${currentUser.uid}/isMicMuted`), isMicMuted);
    set(ref(db, `salas/${currentRoomCode}/usuarios/${currentUser.uid}/isCamOff`), isCamOff);
}

window.toggleMic = (forceState = null) => {
    isMicMuted = forceState !== null ? forceState : !isMicMuted;
    // Habilitar o deshabilitar la pista de audio del stream local
    localStream.getAudioTracks().forEach(track => track.enabled = !isMicMuted);

    const micButton = document.getElementById('micButton');
    const micIcon = micButton.querySelector('img');

    // Cambiar el ícono del botón y el título
    micIcon.src = isMicMuted ? 'mic_off.png' : 'mic.png';
    micButton.title = isMicMuted ? 'Activar Audio' : 'Mutear Audio';

    // Mostrar/ocultar el ícono de estado en tu propio cuadro de video
    localMicStatus.style.display = isMicMuted ? 'block' : 'none';
    
    // Aplicar/quitar clase para el color rojizo del fondo si está muteado
    if (isMicMuted) {
        localVideoContainer.classList.add('muted');
    } else {
        localVideoContainer.classList.remove('muted');
    }

    updateLocalMediaStatusInDB(); // Actualizar estado en Firebase
};

window.toggleCam = (forceState = null) => {
    isCamOff = forceState !== null ? forceState : !isCamOff;
    // Habilitar o deshabilitar la pista de video del stream local
    localStream.getVideoTracks().forEach(track => track.enabled = !isCamOff);

    // Mostrar/ocultar el video en tu propio cuadro
    localVideo.style.display = isCamOff ? 'none' : 'block';
    // El nombre local ahora siempre es visible, no solo cuando la cámara está apagada
    localDisplayName.style.display = 'block'; 

    const camButton = document.getElementById('camButton');
    const camIcon = camButton.querySelector('img');

    // Cambiar el ícono del botón y el título
    camIcon.src = isCamOff ? 'cam_off.png' : 'cam.png';
    camButton.title = isCamOff ? 'Encender Cámara' : 'Apagar Cámara';

    // Mostrar/ocultar el ícono de estado en tu propio cuadro de video
    localCamStatus.style.display = isCamOff ? 'block' : 'none';
    
    // Aplicar/quitar clase para el estilo de cámara apagada
    if (isCamOff) {
        localVideoContainer.classList.add('camera-off');
    } else {
        localVideoContainer.classList.remove('camera-off');
    }

    updateLocalMediaStatusInDB(); // Actualizar estado en Firebase
};

// --- WebRTC Signaling and Connections ---

// Maneja la creación y gestión de las conexiones Peer-to-Peer
function handleWebRTCSignaling(currentParticipants) {
  if (!currentParticipants) return;

  const participantUIDs = Object.keys(currentParticipants);

  // 1. Crear o mantener conexiones con participantes activos
  participantUIDs.forEach(uid => {
    if (uid === currentUser.uid) return; // No crear conexión con uno mismo

    // Si no existe una conexión para este usuario, crearla
    if (!peerConnections[uid]) {
      console.log(`Iniciando conexión con ${currentParticipants[uid].displayName} (${uid})`);
      peerConnections[uid] = createPeerConnection(uid, currentParticipants[uid].displayName);
    }
  });

  // 2. Eliminar conexiones con usuarios que ya no están en la sala
  for (const uid in peerConnections) {
    if (!participantUIDs.includes(uid)) {
      console.log(`Cerrando conexión con usuario que abandonó (${uid}).`);
      peerConnections[uid].close();
      delete peerConnections[uid];
      // Eliminar el contenedor de video remoto de la interfaz
      const remoteVideoDiv = document.getElementById(`remoteVideoContainer-${uid}`);
      if (remoteVideoDiv) {
        remoteVideoDiv.remove();
      }
    }
  }

  // 3. Actualizar la interfaz de usuario para reflejar los estados de los participantes remotos
  for (const uid in currentParticipants) {
      if (uid === currentUser.uid) continue; // Ignorar al usuario actual
      const user = currentParticipants[uid];
      const remoteVideoDiv = document.getElementById(`remoteVideoContainer-${uid}`);
      
      if (remoteVideoDiv) {
          const remoteVideo = remoteVideoDiv.querySelector('video');
          const remoteDisplayName = remoteVideoDiv.querySelector('.remote-display-name');
          const remoteMicStatus = remoteVideoDiv.querySelector('.remote-mic-status');
          const remoteCamStatus = remoteVideoDiv.querySelector('.remote-cam-status');

          // Actualizar estado de la cámara
          if (user.isCamOff) {
              if (remoteVideo) remoteVideo.style.display = 'none'; // Ocultar video
              remoteVideoDiv.classList.add('camera-off'); // Aplicar estilo visual
          } else {
              if (remoteVideo) remoteVideo.style.display = 'block'; // Mostrar video
              remoteVideoDiv.classList.remove('camera-off');
          }
          // El nombre ya no se controla aquí su display, siempre será visible por CSS
          // remoteDisplayName.style.display = 'block'; // Siempre visible por CSS

          // Actualizar estado del micrófono
          if (user.isMicMuted) {
              remoteMicStatus.style.display = 'block'; // Mostrar icono de muteado
              remoteVideoDiv.classList.add('muted'); // Aplicar estilo visual (color rojizo)
          } else {
              remoteMicStatus.style.display = 'none'; // Ocultar icono de muteado
              remoteVideoDiv.classList.remove('muted');
          }

          // Mostrar icono de cámara apagada si aplica
          if (user.isCamOff) {
              remoteCamStatus.style.display = 'block';
          } else {
              remoteCamStatus.style.display = 'none';
          }
      }
  }
}

// Crea una nueva conexión Peer-to-Peer para un usuario remoto
function createPeerConnection(remoteUserUID, remoteUserName) {
    const pc = new RTCPeerConnection({
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' }, // Servidor STUN para ayudar a descubrir IPs públicas
        ]
    });

    // --- Importante: Añadir el stream local a la conexión ---
    // Esto es lo que permite que tu audio y video sean enviados al otro participante.
    if (localStream) {
        localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
        });
    } else {
        console.warn("localStream no está disponible al crear PeerConnection para", remoteUserName);
    }

    // Crear el elemento de video y contenedor para el participante remoto
    const remoteVideoDiv = document.createElement('div');
    remoteVideoDiv.id = `remoteVideoContainer-${remoteUserUID}`;
    remoteVideoDiv.className = 'remote-video-container';

    const videoElement = document.createElement('video');
    videoElement.id = `remoteVideo-${remoteUserUID}`;
    videoElement.autoplay = true;
    videoElement.playsinline = true; // Necesario para que funcione en algunos móviles
    videoElement.className = 'remote-video';

    // Elemento para mostrar el nombre (ahora siempre visible por CSS)
    const displayNameElement = document.createElement('div');
    displayNameElement.className = 'remote-display-name'; // Clase para el nombre
    displayNameElement.textContent = remoteUserName;
    // Ya no se controla el display aquí, el CSS lo hará 'block' por defecto

    // Icono para el estado del micrófono
    const micStatusIcon = document.createElement('img');
    micStatusIcon.src = 'mic_off.png'; // Icono por defecto de muteado
    micStatusIcon.alt = 'Mic Muteado';
    micStatusIcon.className = 'status-icon remote-mic-status';
    micStatusIcon.style.display = 'none'; // Oculto por defecto

    // Icono para el estado de la cámara (se mostrará en la parte superior derecha)
    const camStatusIcon = document.createElement('img');
    camStatusIcon.src = 'cam_off.png'; // Icono por defecto de cámara apagada
    camStatusIcon.alt = 'Cámara Apagada';
    camStatusIcon.className = 'status-icon remote-cam-status';
    camStatusIcon.style.display = 'none'; // Oculto por defecto

    // Añadir elementos al contenedor del video remoto
    remoteVideoDiv.appendChild(videoElement);
    remoteVideoDiv.appendChild(displayNameElement);
    remoteVideoDiv.appendChild(micStatusIcon);
    remoteVideoDiv.appendChild(camStatusIcon);
    // Añadir el nuevo contenedor al área de videos remotos
    document.getElementById('remoteVideoContainer').appendChild(remoteVideoDiv);

    // --- Manejar el evento 'ontrack' ---
    // Este evento se dispara cuando se recibe un nuevo stream de audio/video del otro par.
    pc.ontrack = (event) => {
        console.log(`Track remoto recibido de ${remoteUserName}`);
        // Asignar el stream recibido al elemento de video
        videoElement.srcObject = event.streams[0];
    };

    // --- Manejar el evento 'onicecandidate' ---
    // ICE (Interactive Connectivity Establishment) es un protocolo que ayuda a establecer conexiones P2P.
    // Cuando se encuentra un candidato ICE, lo enviamos al otro par.
    pc.onicecandidate = (event) => {
        if (event.candidate) {
            sendSignalingMessage(remoteUserUID, {
                type: 'candidate',
                candidate: event.candidate
            });
        }
    };
    
    return pc; // Devolver la conexión creada
}


// Configura el listener para recibir mensajes de señalización (ofertas, respuestas, candidatos)
function setupSignalingListener() {
    if (!currentRoomCode || !currentUser) return;
    // Referencia a los mensajes dirigidos a mí
    const mySignalingRef = ref(db, `salas/${currentRoomCode}/signaling/${currentUser.uid}`);

    onValue(mySignalingRef, async (snapshot) => {
        if (snapshot.exists()) {
            const messages = snapshot.val();
            for (const senderUID in messages) {
                const signalingMessage = messages[senderUID];
                
                let pc = peerConnections[senderUID];
                
                // Si no tenemos una conexión activa con el remitente, la creamos.
                if (!pc) {
                    // Necesitamos obtener los datos del remitente para crear la PeerConnection
                    const senderData = await get(ref(db, `salas/${currentRoomCode}/usuarios/${senderUID}`));
                    if (senderData.exists()) {
                        pc = createPeerConnection(senderUID, senderData.val().displayName || 'Usuario Desconocido');
                        peerConnections[senderUID] = pc;
                    } else {
                        console.warn("Datos del remitente no encontrados para oferta:", senderUID);
                        continue; // Si no tenemos datos, no podemos continuar con esta conexión.
                    }
                }

                try {
                    // Procesar el tipo de mensaje de señalización
                    if (signalingMessage.type === 'offer') {
                        // Recibimos una oferta, la aceptamos y enviamos una respuesta.
                        await pc.setRemoteDescription(new RTCSessionDescription(signalingMessage.sdp));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        sendSignalingMessage(senderUID, { type: 'answer', sdp: pc.localDescription });
                    } else if (signalingMessage.type === 'answer') {
                        // Recibimos una respuesta a nuestra oferta.
                        await pc.setRemoteDescription(new RTCSessionDescription(signalingMessage.sdp));
                    } else if (signalingMessage.type === 'candidate') {
                        // Recibimos un candidato ICE para mejorar la conexión.
                        await pc.addIceCandidate(new RTCIceCandidate(signalingMessage.candidate));
                    }
                } catch (error) {
                    console.error(`Error procesando mensaje de señalización de ${senderUID} (${signalingMessage.type}):`, error);
                }

                // Una vez procesado el mensaje, lo eliminamos de Firebase para no procesarlo de nuevo.
                remove(ref(db, `salas/${currentRoomCode}/signaling/${currentUser.uid}/${senderUID}`));
            }
        }
    });
}

// Envía un mensaje de señalización a un usuario específico.
function sendSignalingMessage(targetUserUID, message) {
  if (!currentRoomCode || !currentUser) return;
  // Referencia al lugar donde el usuario destino recibirá el mensaje
  const messagesRef = ref(db, `salas/${currentRoomCode}/signaling/${targetUserUID}/${currentUser.uid}`);
  set(messagesRef, message)
    .catch(error => console.error("Error enviando mensaje de señalización:", error));
}


// Limpiar listeners y cerrar conexiones al salir de la página
window.addEventListener('beforeunload', () => {
    if (participantsListener) {
        off(ref(db, 'salas/' + currentRoomCode + '/usuarios'), participantsListener);
    }
    // Cerrar todas las conexiones Peer-to-Peer activas
    for (const uid in peerConnections) {
        peerConnections[uid].close();
    }
    // Detener el stream de medios local
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }
    // Eliminar al usuario de la sala si aún está conectado
    if (currentUser && currentRoomCode) {
        remove(ref(db, 'salas/' + currentRoomCode + '/usuarios/' + currentUser.uid));
    }
});


// --- Funciones auxiliares para el modal de participantes en call.html ---
function verParticipantesModal() {
    const participantesListDiv = document.getElementById('participantsListCall');
    participantesListDiv.innerHTML = ''; // Limpiar lista anterior

    const salaRef = ref(db, 'salas/' + currentRoomCode + '/usuarios');
    get(salaRef).then((snapshot) => {
        if (snapshot.exists()) {
            const usuarios = snapshot.val();
            for (const uid in usuarios) {
                const user = usuarios[uid];
                const div = document.createElement('div');
                div.textContent = user.displayName || 'Usuario Desconocido';
                // Añadir iconos de estado si aplica
                if (user.isMicMuted) {
                    const micOffIcon = document.createElement('img');
                    micOffIcon.src = 'mic_off.png';
                    micOffIcon.alt = 'Muteado';
                    micOffIcon.style.height = '16px';
                    micOffIcon.style.marginLeft = '5px';
                    div.appendChild(micOffIcon);
                }
                if (user.isCamOff) {
                    const camOffIcon = document.createElement('img');
                    camOffIcon.src = 'cam_off.png';
                    camOffIcon.alt = 'Cámara Apagada';
                    camOffIcon.style.height = '16px';
                    camOffIcon.style.marginLeft = '5px';
                    div.appendChild(camOffIcon);
                }
                div.className = 'participant-call-item';
                participantesListDiv.appendChild(div);
            }
            document.getElementById('participantsModalCall').style.display = 'flex';
        } else {
            alert("No se encontraron participantes para esta sala.");
        }
    }).catch(error => console.error("Error al obtener participantes:", error));
}

function cerrarParticipantesModal() {
    document.getElementById('participantsModalCall').style.display = 'none';
}
</script>

<style>
/* Estilos base y variables CSS */
:root {
  --primary-color: #FF6F00; /* Naranja principal */
  --background-dark: #0f0f1a; /* Fondo oscuro */
  --text-light: #e0e0e0; /* Texto claro */
  --card-background: rgba(255, 255, 255, 0.08); /* Fondo para tarjetas/botones */
  --participant-bg: rgba(255, 255, 255, 0.1); /* Fondo para cuadros de video */
  --muted-red: #e53935; /* Rojo para indicar estado muteado */
}

body {
  margin: 0;
  font-family: 'Montserrat', sans-serif;
  background-color: var(--background-dark);
  color: var(--text-light);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start; /* Alineado arriba para contenido largo */
  min-height: 100vh; /* Altura mínima para ocupar toda la pantalla */
  overflow-y: auto; /* Permitir scroll si el contenido excede la altura */
  padding: 20px;
  box-sizing: border-box; /* Incluir padding en el tamaño total */
}

/* Header de la sala */
.header {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 10px 20px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.header .room-info {
  font-size: 1.1em;
  font-weight: 700;
  color: var(--primary-color);
}

.header .room-code {
  font-size: 1.2em;
  color: white;
  background-color: var(--primary-color);
  padding: 8px 15px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

/* Contenedor principal de la llamada */
.call-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  max-width: 1200px; /* Ancho máximo para no expandirse demasiado */
}

/* Área donde se muestran los videos */
.video-area {
  width: 100%;
  display: grid;
  /* Crea columnas responsivas: cada video tendrá al menos 280px de ancho */
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 15px; /* Espacio entre videos */
  justify-content: center; /* Centrar los videos */
  align-items: start; /* Alinear elementos al inicio si no ocupan todo el espacio */
}

/* Contenedor para el video local y remotos */
#localVideoContainer, .remote-video-container {
  position: relative; /* Para posicionar elementos internos (nombre, iconos) */
  background-color: var(--participant-bg);
  border-radius: 15px; /* Bordes redondeados */
  overflow: hidden; /* Asegura que el video no se salga de los bordes */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  aspect-ratio: 16 / 9; /* Mantiene la proporción del video */
  min-width: 280px; /* Ancho mínimo */
  box-shadow: 0 4px 15px rgba(0,0,0,0.4);
  transition: background-color 0.3s ease, border 0.3s ease; /* Transición suave para cambios */
  border: 2px solid transparent; /* Borde inicial transparente */
}

/* Estilo cuando el usuario está muteado */
#localVideoContainer.muted, .remote-video-container.muted {
    background-color: rgba(var(--muted-red), 0.3); /* Fondo semitransparente rojizo */
    border: 2px solid var(--muted-red); /* Borde rojizo */
}

/* Estilo cuando la cámara está apagada */
#localVideoContainer.camera-off, .remote-video-container.camera-off {
    background-color: rgba(100, 100, 100, 0.2); /* Fondo grisáceo */
}

/* El elemento video */
#localVideo, .remote-video {
  width: 100%;
  height: 100%;
  object-fit: cover; /* Cubre el contenedor manteniendo la relación de aspecto */
  transform: scaleX(-1); /* Refleja el video horizontalmente (estándar para video local) */
  display: block; /* Asegura que se muestre */
}
/* Aplica el mismo reflejo a los videos remotos para consistencia */
.remote-video-container .remote-video {
    transform: scaleX(-1);
}

/* Nombre del usuario (ahora SIEMPRE visible en la esquina inferior izquierda) */
#localDisplayName, .remote-display-name {
  position: absolute;
  bottom: 10px; /* Abajo */
  left: 10px; /* A la izquierda */
  font-size: 0.9em; /* Más pequeño */
  font-weight: 700;
  color: white;
  text-shadow: 0 1px 3px rgba(0,0,0,0.6);
  z-index: 10; /* Asegura que esté sobre el video */
  padding: 4px 8px; /* Padding pequeño */
  background: rgba(0, 0, 0, 0.5); /* Fondo semitransparente */
  border-radius: 6px;
  display: block; /* SIEMPRE VISIBLE */
  text-align: center;
  pointer-events: none; /* No interfiere con eventos del ratón */
  /* Removemos el transform: translate(-50%, -50%); para que se posicione directamente con bottom/left */
}

/* Iconos de estado (micrófono muteado, cámara apagada) */
.status-icon {
    position: absolute; /* Posicionado sobre el video */
    top: 10px;
    right: 10px;
    height: 30px;
    width: 30px;
    background-color: rgba(0, 0, 0, 0.5); /* Fondo semitransparente */
    border-radius: 50%; /* Forma circular */
    padding: 5px;
    z-index: 10; /* Sobre el video y nombre */
    display: none; /* Oculto por defecto, se mostrará con JS */
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

/* Posición específica para el icono de estado de la cámara */
.status-icon.remote-cam-status, .status-icon.local-cam-status {
    top: 10px; /* Arriba */
    right: 10px; /* Derecha */
    transform: none; /* Asegura que no haya transformaciones que lo muevan */
}

/* Posición específica para el icono de estado del micrófono */
.status-icon.remote-mic-status, .status-icon.local-mic-status {
    top: 10px; /* Arriba */
    /* Lo movemos a la izquierda del icono de cámara si ambos están presentes */
    right: 50px; /* Ajusta esto según el tamaño de tu icono de cámara */
    transform: none;
}


/* Controles de la llamada (botones) */
.controls {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap; /* Permite que los botones se acomoden en varias líneas */
  gap: 15px; /* Espacio entre botones */
  margin-top: 20px;
}

.controls button {
  cursor: pointer;
  font-size: 16px;
  font-weight: 700;
  border: none;
  border-radius: 10px;
  padding: 12px 25px;
  transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-light);
  background-color: var(--card-background);
}

.controls button:hover {
  transform: translateY(-3px) scale(1.03); /* Efecto al pasar el ratón */
  box-shadow: 0 4px 15px rgba(255, 111, 0, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3);
}

.controls button img {
    height: 24px;
    width: 24px;
}

/* Botón de abandonar llamada */
.controls .leave-button {
  background-color: #e53935; /* Rojo */
  color: white;
}
.controls .leave-button:hover {
  background-color: #f44336; /* Rojo más brillante */
  box-shadow: 0 4px 15px rgba(229, 57, 53, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3);
}

/* Modal para mostrar la lista de participantes */
#participantsModalCall {
  position: fixed; /* Cubre toda la pantalla */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(15, 15, 26, 0.95); /* Fondo oscuro semitransparente */
  display: none; /* Oculto por defecto */
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000; /* Asegura que esté sobre todo lo demás */
  backdrop-filter: blur(5px); /* Efecto de desenfoque al fondo */
}

#participantsModalCall .modal-content {
  background: rgba(30, 30, 50, 0.8); /* Fondo del contenido del modal */
  padding: 30px;
  border-radius: 15px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 90%;
  max-width: 450px; /* Ancho máximo del modal */
  text-align: center;
}

#participantsModalCall h3 {
  font-size: 26px;
  margin-bottom: 20px;
  color: var(--primary-color);
  font-weight: 700;
}

#participantsListCall {
  display: flex;
  flex-direction: column;
  gap: 10px; /* Espacio entre elementos de la lista */
  max-height: 40vh; /* Altura máxima para permitir scroll */
  overflow-y: auto; /* Scroll vertical si el contenido excede max-height */
  margin-bottom: 25px;
  width: 100%;
  padding-right: 10px; /* Espacio para la barra de scroll */
}

.participant-call-item {
  background: var(--card-background);
  padding: 10px 18px;
  border-radius: 8px;
  font-size: 17px;
  color: var(--text-light);
  text-align: left;
  transition: background-color 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: space-between; /* Alinea el contenido a ambos lados */
}
.participant-call-item img {
    margin-left: 10px; /* Espacio entre el texto y los iconos de estado */
}

/* Botón de cerrar del modal */
#participantsModalCall .modal-content button {
  background: var(--primary-color);
  color: white;
  width: auto;
  padding: 12px 30px;
}
#participantsModalCall .modal-content button:hover {
  background: #FF8F33; /* Color hover para el botón de cerrar */
}

/* Media Query para ajustar el diseño en pantallas pequeñas (móviles) */
@media (max-width: 768px) {
  .header {
    flex-direction: column; /* Apila los elementos del header verticalmente */
    gap: 10px;
  }
  .call-container {
    gap: 15px;
  }
  .video-area {
    grid-template-columns: 1fr; /* Una sola columna para videos */
  }
  .controls {
    flex-wrap: wrap; /* Los botones de control se envuelven */
  }
  .controls button {
    width: 100%; /* Los botones de control ocupan todo el ancho */
    justify-content: center; /* Centra el contenido del botón */
  }
}
</style>
</head>
<body>

<header class="header">
  <div class="room-info">Sala: <span id="roomCodeDisplay"></span></div>
  <button onclick="verParticipantesModal()" class="mute-button">Ver Participantes</button>
  <button onclick="leaveRoom()" class="leave-button">Abandonar Sala</button>
</header>

<div class="call-container">
  <div class="video-area">
    <div id="localVideoContainer">
      <video id="localVideo" autoplay playsinline></video>
      <div id="localDisplayName" class="display-name"></div>
      <img id="localMicStatus" src="mic_off.png" alt="Muteado" class="status-icon local-mic-status">
      <img id="localCamStatus" src="cam_off.png" alt="Cámara Apagada" class="status-icon local-cam-status">
    </div>
    <div id="remoteVideoContainer">
    </div>
  </div>

  <div class="controls">
    <button id="micButton" onclick="toggleMic()" title="Mutear Audio">
      <img src="mic.png" alt="Micrófono">
      <span>Audio</span>
    </button>
    <button id="camButton" onclick="toggleCam()" title="Apagar Cámara">
      <img src="cam.png" alt="Cámara">
      <span>Video</span>
    </button>
  </div>
</div>

<div id="participantsModalCall">
  <div class="modal-content">
    <h3>Participantes en la Sala</h3>
    <div id="participantsListCall"></div>
    <button onclick="cerrarParticipantesModal()">Cerrar</button>
  </div>
</div>

</body>
</html>
