<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Naio - Llamada</title>
<link rel="icon" href="Naio.png">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-auth.js";
import { getDatabase, ref, onValue, set, get, push, remove, off } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-database.js";

// --- Configuración de Firebase (MISMA CONFIGURACIÓN QUE EN index.html) ---
const firebaseConfig = {
  apiKey: "AIzaSyCmzxzDSJFPt7-fDti1PRC-boDE30cJEbM",
  authDomain: "naio1092ngs.firebaseapp.com",
  projectId: "naio1092ngs",
  storageBucket: "naio1092ngs.firebasestorage.app",
  messagingSenderId: "874452485775",
  appId: "1:874452485775:web:25e5ed586fcebe93e952fa",
  measurementId: "G-JBK153N8XL"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

let currentUser = null;
let currentRoomCode = null;
let participantsListener = null; // Para escuchar cambios en los participantes

// --- Manejo de Usuario y Redirección ---

onAuthStateChanged(auth, (user) => {
  if (user) {
    currentUser = user;
    const params = new URLSearchParams(window.location.search);
    currentRoomCode = params.get('codigo');

    if (!currentRoomCode) {
      alert("No se especificó un código de sala.");
      window.location.href = "index.html"; // Volver al inicio
      return;
    }

    document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
    joinRoom(currentRoomCode);
  } else {
    // Si el usuario cierra sesión mientras está en la página de llamada
    alert("Debes iniciar sesión para continuar.");
    window.location.href = "index.html";
  }
});

// --- Lógica de Sala y Participantes ---

function joinRoom(codigo) {
  const salaRef = ref(db, 'salas/' + codigo);
  const usuariosSalaRef = ref(db, 'salas/' + codigo + '/usuarios');

  // Añadir al usuario actual a la sala si no está ya
  set(ref(db, 'salas/' + codigo + '/usuarios/' + currentUser.uid), currentUser.displayName)
    .then(() => {
      console.log(`Usuario ${currentUser.displayName} unido a la sala ${codigo}`);
      updateParticipantListUI(); // Actualizar la lista inicial
      // Escuchar cambios en la lista de usuarios
      participantsListener = onValue(usuariosSalaRef, (snapshot) => {
        updateParticipantListUI();
        // Aquí iría la lógica para iniciar/gestionar llamadas WebRTC
        handleWebRTCSignaling(snapshot.val());
      });
    })
    .catch((error) => {
      console.error("Error al unirse a la sala o al escuchar participantes:", error);
      alert("No pudimos unirnos a la sala. Verifica el código e inténtalo de nuevo.");
      window.location.href = "index.html";
    });

  // Configurar listener para saber si la sala se ha cerrado
  const salaActivaRef = ref(db, 'salas/' + codigo + '/activo');
  onValue(salaActivaRef, (snapshot) => {
      if (!snapshot.exists() || !snapshot.val()) {
          alert("La sala ha sido cerrada por el creador.");
          leaveRoom();
      }
  }, { onlyOnce: false }); // Escuchar continuamente
}

function updateParticipantListUI() {
  const salaRef = ref(db, 'salas/' + currentRoomCode + '/usuarios');
  get(salaRef).then((snapshot) => {
    const participantesListDiv = document.getElementById('participantsListCall');
    participantesListDiv.innerHTML = ''; // Limpiar lista anterior
    if (snapshot.exists()) {
      const usuarios = snapshot.val();
      for (const uid in usuarios) {
        const div = document.createElement('div');
        div.textContent = usuarios[uid];
        div.className = 'participant-call-item';
        participantesListDiv.appendChild(div);
      }
    }
  }).catch(error => console.error("Error actualizando lista de participantes:", error));
}

window.leaveRoom = () => {
  if (currentUser && currentRoomCode) {
    // Eliminar al usuario de la sala
    remove(ref(db, 'salas/' + currentRoomCode + '/usuarios/' + currentUser.uid))
      .then(() => {
        console.log(`Usuario ${currentUser.displayName} abandonó la sala ${currentRoomCode}`);
        // Si el usuario era el creador, opcionalmente se podría cerrar la sala
        // Aquí se detendría la escucha de participantes para esta sala
        if (participantsListener) {
          off(ref(db, 'salas/' + currentRoomCode + '/usuarios'), participantsListener);
          participantsListener = null;
        }
        window.location.href = "index.html"; // Volver al lobby
      })
      .catch((error) => {
        console.error("Error al abandonar la sala:", error);
        alert("Ocurrió un error al intentar abandonar la sala.");
        window.location.href = "index.html";
      });
  } else {
    window.location.href = "index.html"; // Si no hay sesión o código, volver al inicio
  }
}

// --- Lógica de WebRTC (¡AQUÍ ES DONDE NECESITAS TRABAJAR!) ---

// --- ESTA PARTE ES UN ESQUELETO Y NECESITA SER COMPLETADA ---

// Obteniendo acceso a cámara y micrófono
let localStream = null;
const localVideo = document.getElementById('localVideo');
const remoteVideoContainer = document.getElementById('remoteVideoContainer'); // Contenedor para videos remotos

async function startMediaStream() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;
    localVideo.muted = true; // Silenciar nuestro propio audio para evitar eco
    console.log("Stream de medios iniciado.");
  } catch (error) {
    console.error("Error al acceder a la cámara o micrófono:", error);
    alert("No se pudo acceder a tu cámara o micrófono. Por favor, verifica los permisos.");
  }
}

// Objeto para manejar las conexiones WebRTC
const peerConnections = {}; // Guarda las conexiones por UID del otro usuario
let signalingChannel = null; // Canal de señalización (lo implementaremos con Firebase RTDB)

function handleWebRTCSignaling(currentParticipants) {
  console.log("Participantes actuales:", currentParticipants);

  // Lógica para:
  // 1. Iniciar llamadas con nuevos participantes
  // 2. Cerrar conexiones con participantes que se van
  // 3. Intercambiar señales (ofertas, respuestas, candidatos ICE)

  if (!currentParticipants) return;

  const participantUIDs = Object.keys(currentParticipants);

  // Para cada participante, asegúrate de que haya una conexión y señalización
  participantUIDs.forEach(uid => {
    if (uid === currentUser.uid) return; // No creamos conexión con nosotros mismos

    if (!peerConnections[uid]) {
      console.log(`Iniciando conexión con ${currentParticipants[uid]} (${uid})`);
      // Crear nueva conexión y manejador de señales
      peerConnections[uid] = createPeerConnection(uid);
      // Aquí deberías enviar la oferta inicial si eres el primero en conectarte
      // o responder si recibes una oferta.
      // Esto requiere una lógica más compleja de intercambio de señales.
    }
  });

  // Eliminar conexiones con usuarios que ya no están en la sala
  for (const uid in peerConnections) {
    if (!participantUIDs.includes(uid)) {
      console.log(`Cerrando conexión con ${currentParticipants[uid] || 'un usuario'} (${uid})`);
      peerConnections[uid].close();
      delete peerConnections[uid];
      // Eliminar el video del usuario remoto de la UI
      const remoteVideo = document.getElementById(`remoteVideo-${uid}`);
      if (remoteVideo) {
        remoteVideo.remove();
      }
    }
  }
}

function createPeerConnection(remoteUserUID) {
  // Configurar RTCPeerConnection
  const pc = new RTCPeerConnection({
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' }, // Servidor STUN público
      // Se pueden añadir servidores TURN para NAT traversal más robusto
    ]
  });

  // Manejar cuando llega un stream remoto (de otro usuario)
  pc.ontrack = (event) => {
    console.log(`Track remoto recibido de ${remoteUserUID}`);
    const remoteStream = event.streams[0];
    const videoElement = document.createElement('video');
    videoElement.id = `remoteVideo-${remoteUserUID}`;
    videoElement.srcObject = remoteStream;
    videoElement.autoplay = true;
    videoElement.playsinline = true;
    videoElement.controls = true; // Opcional: mostrar controles de video
    videoElement.className = 'remote-video';
    remoteVideoContainer.appendChild(videoElement);
  };

  // Manejar candidatos ICE (información de red)
  pc.onicecandidate = (event) => {
    if (event.candidate) {
      console.log("Enviando candidato ICE:", event.candidate);
      // Enviar este candidato al otro usuario a través del canal de señalización
      sendSignalingMessage(remoteUserUID, {
        type: 'candidate',
        candidate: event.candidate
      });
    }
  };

  // Añadir nuestro stream local a la conexión
  if (localStream) {
    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
    });
  } else {
    console.warn("localStream no está disponible al crear PeerConnection.");
  }

  return pc;
}

// Función para enviar mensajes de señalización a un usuario específico
function sendSignalingMessage(targetUserUID, message) {
  if (!currentRoomCode) return;
  // Usar Firebase RTDB para enviar el mensaje a un nodo específico
  const messagesRef = ref(db, `salas/${currentRoomCode}/signaling/${targetUserUID}/${currentUser.uid}`);
  set(messagesRef, message)
    .then(() => console.log(`Mensaje de señalización enviado a ${targetUserUID}:`, message))
    .catch(error => console.error("Error enviando mensaje de señalización:", error));
}

// Configurar listener para recibir mensajes de señalización
function setupSignalingListener() {
  if (!currentRoomCode) return;
  const signalingRoomRef = ref(db, `salas/${currentRoomCode}/signaling`);

  // Escuchar mensajes para nuestro UID
  const mySignalingRef = ref(db, `salas/${currentRoomCode}/signaling/${currentUser.uid}`);
  onValue(mySignalingRef, async (snapshot) => {
    if (snapshot.exists()) {
      const message = snapshot.val();
      const senderUID = Object.keys(snapshot.val())[0]; // El UID del que envía el mensaje
      const signalingMessage = message[senderUID];

      console.log(`Mensaje de señalización recibido de ${senderUID}:`, signalingMessage);

      // Procesar el mensaje
      if (signalingMessage.type === 'offer') {
        // Si recibimos una oferta, creamos la conexión si no existe y respondemos
        if (!peerConnections[senderUID]) {
          peerConnections[senderUID] = createPeerConnection(senderUID);
        }
        await peerConnections[senderUID].setRemoteDescription(new RTCSessionDescription(signalingMessage.sdp));
        const answer = await peerConnections[senderUID].createAnswer();
        await peerConnections[senderUID].setLocalDescription(answer);
        sendSignalingMessage(senderUID, { type: 'answer', sdp: peerConnections[senderUID].localDescription });

      } else if (signalingMessage.type === 'answer') {
        // Si recibimos una respuesta, la aplicamos a la conexión existente
        if (peerConnections[senderUID]) {
          await peerConnections[senderUID].setRemoteDescription(new RTCSessionDescription(signalingMessage.sdp));
        } else {
          console.warn("Recibida respuesta sin conexión previa para", senderUID);
        }

      } else if (signalingMessage.type === 'candidate') {
        // Si recibimos un candidato ICE, lo añadimos a la conexión
        if (peerConnections[senderUID]) {
          await peerConnections[senderUID].addIceCandidate(new RTCIceCandidate(signalingMessage.candidate));
        } else {
          console.warn("Recibido candidato ICE sin conexión previa para", senderUID);
        }
      } else if (signalingMessage.type === 'join') {
          // Cuando un nuevo usuario se une, se le puede enviar una oferta
          if (!peerConnections[senderUID]) {
              peerConnections[senderUID] = createPeerConnection(senderUID);
              const offer = await peerConnections[senderUID].createOffer();
              await peerConnections[senderUID].setLocalDescription(offer);
              sendSignalingMessage(senderUID, { type: 'offer', sdp: peerConnections[senderUID].localDescription });
          }
      }

      // Una vez procesado, eliminamos el mensaje de la cola de señalización
      remove(ref(db, `salas/${currentRoomCode}/signaling/${currentUser.uid}/${senderUID}`));
    }
  });
}


// Iniciar todo al cargar la página y autenticarse
window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const roomCodeFromUrl = urlParams.get('codigo');

  if (!roomCodeFromUrl) {
    alert("Error: No se especificó un código de sala.");
    window.location.href = "index.html";
    return;
  }

  document.getElementById('roomCodeDisplay').textContent = roomCodeFromUrl;
  currentRoomCode = roomCodeFromUrl;

  // Iniciar el stream de medios (cámara/micrófono)
  startMediaStream();
  // Configurar el listener para recibir mensajes de señalización
  setupSignalingListener();
};

// Limpiar listeners al salir de la página
window.addEventListener('beforeunload', () => {
    if (participantsListener) {
        off(ref(db, 'salas/' + currentRoomCode + '/usuarios'), participantsListener);
    }
    // Aquí también se podrían cerrar todas las conexiones WebRTC activas
    for (const uid in peerConnections) {
        peerConnections[uid].close();
    }
    // Podríamos eliminar al usuario de la sala aquí si no queremos que se quede "conectado"
    // pero leaveRoom ya lo hace.
});

</script>

<style>
:root {
  --primary-color: #FF6F00;
  --background-dark: #0f0f1a;
  --text-light: #e0e0e0;
  --card-background: rgba(255, 255, 255, 0.08);
  --participant-bg: rgba(255, 255, 255, 0.1);
}

body {
  margin: 0;
  font-family: 'Montserrat', sans-serif;
  background-color: var(--background-dark);
  color: var(--text-light);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start; /* Alinea al inicio para que los videos tengan espacio */
  min-height: 100vh;
  overflow-y: auto; /* Permitir scroll si hay muchos videos */
  padding: 20px;
  box-sizing: border-box;
}

.header {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 10px 20px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
}

.header .room-info {
  font-size: 1.1em;
  font-weight: 700;
  color: var(--primary-color);
}

.header .room-code {
  font-size: 1.2em;
  color: white;
  background-color: var(--primary-color);
  padding: 8px 15px;
  border-radius: 8px;
}

.call-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  max-width: 1200px; /* Ancho máximo para el área de video */
}

.video-area {
  width: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* Layout adaptable */
  gap: 15px;
  justify-content: center;
  align-items: start; /* Alinea los videos al inicio */
}

#localVideoContainer {
  position: relative; /* Para posicionar el overlay de "Tú" */
  background-color: var(--participant-bg);
  border-radius: 10px;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  aspect-ratio: 16 / 9; /* Relación de aspecto para el video */
  min-width: 250px; /* Mínimo tamaño */
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

#localVideo {
  width: 100%;
  height: 100%;
  object-fit: cover; /* Cubre el contenedor sin distorsionar */
  transform: scaleX(-1); /* Voltear horizontalmente para ver como en un espejo */
}

#remoteVideoContainer {
  display: contents; /* Permite que los videos remotos se fusionen en el grid */
}

.remote-video {
  width: 100%;
  height: auto; /* Ajusta la altura automáticamente */
  background-color: var(--participant-bg);
  border-radius: 10px;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  aspect-ratio: 16 / 9;
  min-width: 250px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

/* Estilos para el overlay de "Tú" */
#localVideoContainer::before {
  content: "Tú";
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 14px;
  font-weight: 700;
  z-index: 10;
}

.controls {
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px;
  margin-top: 20px;
}

.controls button {
  cursor: pointer;
  font-size: 16px;
  font-weight: 700;
  border: none;
  border-radius: 10px;
  padding: 12px 25px;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  gap: 8px;
}

.controls button:hover {
  transform: translateY(-3px) scale(1.03);
  box-shadow: 0 4px 15px rgba(255, 111, 0, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3);
}

.controls .leave-button {
  background-color: #e53935; /* Rojo */
  color: white;
}
.controls .leave-button:hover {
  background-color: #f44336;
  box-shadow: 0 4px 15px rgba(229, 57, 53, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3);
}

.controls .mute-button, .controls .video-button {
  background-color: var(--card-background);
  color: var(--text-light);
  border: 1px solid rgba(255, 255, 255, 0.3);
}
.controls .mute-button:hover, .controls .video-button:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

/* Estilos para el modal de participantes (puede ser similar al de index.html) */
#participantsModalCall {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(15, 15, 26, 0.95);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(5px);
}

#participantsModalCall .modal-content {
  background: rgba(30, 30, 50, 0.8);
  padding: 30px;
  border-radius: 15px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 90%;
  max-width: 450px;
  text-align: center;
}

#participantsModalCall h3 {
  font-size: 26px;
  margin-bottom: 20px;
  color: var(--primary-color);
  font-weight: 700;
}

#participantsListCall {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 40vh;
  overflow-y: auto;
  margin-bottom: 25px;
  width: 100%;
  padding-right: 10px;
}

.participant-call-item {
  background: var(--card-background);
  padding: 10px 18px;
  border-radius: 8px;
  font-size: 17px;
  color: var(--text-light);
  text-align: left;
  transition: background-color 0.2s ease;
}

.participant-call-item:hover {
  background: rgba(255, 255, 255, 0.15);
}

#participantsModalCall .modal-content button {
  background: var(--primary-color);
  color: white;
  width: auto;
  padding: 12px 30px;
}
#participantsModalCall .modal-content button:hover {
  background: #FF8F33;
}

/* Ajustes para pantallas pequeñas */
@media (max-width: 768px) {
  .header {
    flex-direction: column;
    gap: 10px;
  }
  .call-container {
    gap: 15px;
  }
  .video-area {
    grid-template-columns: 1fr; /* Un solo video por fila en móviles */
  }
  .controls {
    flex-wrap: wrap; /* Los controles se apilan si no caben */
  }
}
</style>
</head>
<body>

<header class="header">
  <div class="room-info">Sala: <span id="roomCodeDisplay"></span></div>
  <button onclick="verParticipantesModal()" class="mute-button">Ver Participantes</button>
  <button onclick="leaveRoom()" class="leave-button">Abandonar Sala</button>
</header>

<div class="call-container">
  <div class="video-area">
    <div id="localVideoContainer">
      <video id="localVideo" autoplay playsinline></video>
    </div>

    <div id="remoteVideoContainer">
      </div>
  </div>

  <div class="controls">
    <button class="mute-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a6 6 0 0 0-6 6v7a6 6 0 0 0 12 0v-7a6 6 0 0 0-6-6z"></path><path d="M19 10v4a6 6 0 0 1-12 0v-4"></path><path d="M12 17v5"></path><path d="M8 21h8"></path></svg>
      Mutear Audio
    </button>
    <button class="video-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 6a2 2 0 0 0-2-2h-14a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z"></path><path d="M11 16l-4 4"></path><path d="M15 16l4 4"></path></svg>
      Detener Video
    </button>
  </div>
</div>

<div id="participantsModalCall">
  <div class="modal-content">
    <h3>Participantes en la Sala</h3>
    <div id="participantsListCall"></div>
    <button onclick="cerrarParticipantesModal()">Cerrar</button>
  </div>
</div>

<script>
// --- Funciones auxiliares para el modal de participantes en call.html ---
function verParticipantesModal() {
    const participantesListDiv = document.getElementById('participantsListCall');
    participantesListDiv.innerHTML = ''; // Limpiar lista anterior

    const salaRef = ref(db, 'salas/' + currentRoomCode + '/usuarios');
    get(salaRef).then((snapshot) => {
        if (snapshot.exists()) {
            const usuarios = snapshot.val();
            for (const uid in usuarios) {
                const div = document.createElement('div');
                div.textContent = usuarios[uid];
                div.className = 'participant-call-item';
                participantesListDiv.appendChild(div);
            }
            document.getElementById('participantsModalCall').style.display = 'flex';
        } else {
            alert("No se encontraron participantes para esta sala.");
        }
    }).catch(error => console.error("Error al obtener participantes:", error));
}

function cerrarParticipantesModal() {
    document.getElementById('participantsModalCall').style.display = 'none';
}
</script>

</body>
</html>
